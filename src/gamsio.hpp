// Copyright (C) 2020 Benoit Chachuat, Imperial College London.
// All Rights Reserved.
// This code is published under the Eclipse Public License.

/*!
\page page_GAMSIO GAMS File Reader for CANON
\author Benoit Chachuat <tt>(b.chachuat@imperial.ac.uk)</tt>
\version 1.0
\date 2020
\bug No known bugs.

*/

//TODO: 
//- documentation

#ifndef MC__GAMSIO_HPP
#define MC__GAMSIO_HPP

#if defined (MC__WITH_GAMS)
#include <sys/stat.h>
#include <cstdio>
#include <sstream>
#include <fstream>
//#include <errno.h>
 
#include "gmomcc.h"
#include "gevmcc.h"
#include "palmcc.h"
#include "GamsNLinstr.h"
#define MC__GAMS_SSSIZE 256
#endif

#include "base_nlp.hpp"

#define MC__GAMSIO_DEBUG
#define MC__GAMSIO_TRACE

namespace mc
{

//! @brief C++ class for importing a GAMS model into CANON
////////////////////////////////////////////////////////////////////////
//! mc::GAMSIO is a C++ class for importing a GAMS model into
//! CANON. It relies on the GAMS model object (GMO) generated by GAMS,
//! and uses the GAMS C API (header files gmomcc.h, gevmcc.h) and
//! GAMSLink in COIN (header files GamsNLinstr.h, GamsCompatibility.h).
//! The implementation is heavily inspired by the GMO file reader by
//! Stefan Vigerske for the solver SCIP (C files reader_gmo.h,
//! reader_gmo.c, reader_gms.h, reader_gms.c; see https://scip.zib.de/doc/html/).
////////////////////////////////////////////////////////////////////////
class GAMSIO:
  public virtual BASE_NLP
{
public:
  //! @brief Class constructor
  GAMSIO
    ()
    : BASE_NLP(),
      _gmo( nullptr ),
      _gev( nullptr ),
      //_pal( nullptr ),
      _dag( nullptr ),
      _nvar( 0 ),
      _nctr( 0 )
    {}

  //! @brief Class destructor
  virtual ~GAMSIO()
    { 
      //if( _pal ) palFree( &_pal );
      delete _dag;
    }

  //! @brief GAMS reader
#if defined (MC__WITH_GAMS)
  bool read
    ( std::string const filename, bool const disp=false );
#endif

  //! @brief GAMS API
  bool read
    ( struct gmoRec* gmo, bool const disp=false );

private:
   //! @brief GAMS modeling object
   struct gmoRec*        _gmo;

   //! @brief GAMS environment
   struct gevRec*        _gev;

   //! @brief GAMS audit and license object
   //struct palRec*        _pal;

  //! @brief DAG environment
  FFGraph* _dag;

  //! @brief setup optimization model from GAMS modelling object
  bool _populate
    ( bool const disp );
    
  //! @brief parse nonlinear function from GAMS modelling object
  std::pair<FFVar,bool> _parse
    ( int const codelen, std::vector<int>& opcodes, std::vector<int>& fields,
      double const* constants );

protected:
  //! @brief number of variables
  int _nvar;
  
  //! @brief number of constraints
  int _nctr;

  //! @brief variable initial values
  std::vector<double> _varini;
};

#if defined (MC__WITH_GAMS)
inline
bool
GAMSIO::read
( std::string const filename, bool const disp )
{
  // reset
  _gmo = nullptr;
  _gev = nullptr;
  bool flag = false;

  // create temporary directory
  if( mkdir( "loadgms.tmp", S_IRWXU ) ){ 
    std::cerr << "Could not create temporary subdirectory. Do you have write permissions in execution directory?" << std::endl;
    return flag;
  }

  // create empty convertd options file */
  std::ofstream convertdopt;
  convertdopt.open( "loadgms.tmp/convertd.opt", std::ios::trunc );
  if( !convertdopt.is_open() ){
    std::cerr << "Could not create convertd options file. Do you have write permissions in execution directory?" << std::endl;
    goto TERMINATE;
  }
  convertdopt << "ConeReform  1\nTerminate\n";
  convertdopt.close();
 
  // call GAMS with convertd solver to get compiled model instance in temporary directory
  {std::ostringstream GamsCall;
  GamsCall << MC__WITH_GAMS << "/gams " << filename << " LP=CONVERTD RMIP=CONVERTD QCP=CONVERTD RMIQCP=CONVERTD NLP=CONVERTD DNLP=CONVERTD RMINLP=CONVERTD CNS=CONVERTD MIP=CONVERTD MIQCP=CONVERTD MINLP=CONVERTD MCP=CONVERTD MPEC=CONVERTD RMPEC=CONVERTD SCRDIR=loadgms.tmp output=loadgms.tmp/listing optdir=loadgms.tmp optfile=1 pf4=0 solprint=0 limcol=0 limrow=0 pc=2 lo=" << (disp? 3: 0);
  int rc = system( GamsCall.str().c_str() );
  if( rc ){
    std::cerr << "GAMS call returned with code " << rc << ", check loadgms.tmp/listing for details." << std::endl;
    goto TERMINATE;
  }}
   
  // initialize GEV & GMO libraries and create _gev & _gmo
  char buffer[MC__GAMS_SSSIZE];
  if( !gevCreate( &_gev, buffer, sizeof(buffer) ) 
   || !gmoCreate( &_gmo, buffer, sizeof(buffer) ) ){
    std::cerr << buffer << std::endl;
    goto TERMINATE;
  }
 
  // load control file
  if( gevInitEnvironmentLegacy( _gev, "loadgms.tmp/gamscntr.dat" ) ){
    std::cerr << "Could not load control file loadgms.tmp/gamscntr.dat" << std::endl;
    goto TERMINATE;
  }
 
  // tell _gmo about _gev
  if( gmoRegisterEnvironment( _gmo, _gev, buffer) )
  {
    std::cerr << "Error registering GAMS Environment: " << buffer << std::endl;
    goto TERMINATE;
  }
 
  // load GAMS model instance into _gmo
  if( gmoLoadDataLegacy( _gmo, buffer) ){
    std::cerr << "Could not load model data." << std::endl;
    goto TERMINATE;
  }

  // populate optimization model out of _gmo
  flag = _populate( disp );

TERMINATE:
  // clean-up
  if( _gmo ) gmoFree( &_gmo );
  if( _gev ) gevFree( &_gev );
  system( "rm loadgms.tmp/* && rmdir loadgms.tmp" );

  return flag;
}
#endif

inline
bool
GAMSIO::read
( struct gmoRec* gmo, bool const disp )
{
   _gmo = gmo;
   if( _gmo == nullptr ){
     std::cerr << "GMO is a null pointer" << std::endl;
     return false;
   }

   _gev = (gevRec*)gmoEnvironment( gmo );
   if( _gev == nullptr ){
     std::cerr << "GEV is a null pointer" << std::endl;
     return false;
   }

   //char buffer[MC__GAMS_SSSIZE];
   //if( _pal == nullptr && !palCreate( &_pal, buffer, sizeof(buffer)) )
   //{
   //  gevLogStat( _gev, buffer );
   //  return false;
   //}
//#if PALAPIVERSION >= 3
//   palSetSystemName( _pal, "CANON" );
//   palGetAuditLine( _pal, buffer );
//   gevLogStat( _gev, "" );
//   gevLogStat( _gev, buffer );
//   gevStatAudit( _gev, buffer );
//#endif

//   GAMSinitLicensing( _gmo, _pal );
//#ifdef GAMS_BUILD
//   ipoptlicensed = GAMScheckIpoptLicense(pal, false);
//   if( ipoptlicensed )
//      GamsHSLInit();
//#endif

   gevLogStatPChar( _gev, "\nCANON (ver. 1.0)\nwritten by Benoit Chachuat\n\n");

   return _populate( disp );
}

inline
bool
GAMSIO::_populate
( bool const disp )
{
  assert( _gmo != nullptr );
  gmoInterfaceSet( _gmo, gmoIFace_Raw );
  gmoObjStyleSet( _gmo, gmoObjType_Fun );
  gmoObjReformSet( _gmo, 1 );
  gmoIndexBaseSet( _gmo, 0 );
  gmoUseQSet( _gmo, 1 );

  // get rid of free rows
  if( gmoGetEquTypeCnt( _gmo, gmoequ_N ) )
    gmoSetNRowPerm( _gmo );

   // CANON cannot handle problems without decision variables
   if( !gmoN( _gmo ) ){
     gevLogStat( _gev, "Error: CANON requires variables.\n" );
     gmoSolveStatSet( _gmo, gmoSolveStat_Capability );
     gmoModelStatSet( _gmo, gmoModelStat_NoSolutionReturned );
     return false;
   }

  // CANON cannot handle semicontinuous, semiinteger or SOS
  if( gmoGetVarTypeCnt( _gmo, gmovar_SC ) > 0
   || gmoGetVarTypeCnt( _gmo, gmovar_SI ) > 0 ){
    gevLogStat( _gev, "ERROR: Semicontinuous and semiinteger variables not supported in CANON.\n" );
    gmoSolveStatSet( _gmo, gmoSolveStat_Capability );
    gmoModelStatSet( _gmo, gmoModelStat_NoSolutionReturned );
    return false;
  }

  if( gmoGetVarTypeCnt( _gmo, gmovar_S1 ) > 0
   || gmoGetVarTypeCnt( _gmo, gmovar_S2 ) > 0 ){
    gevLogStat( _gev, "ERROR: Special ordered sets not supported in CANON.\n");
    gmoSolveStatSet( _gmo, gmoSolveStat_Capability );
    gmoModelStatSet( _gmo, gmoModelStat_NoSolutionReturned );
    return false;
  }

  // process options file
  try{
    if( gmoOptFile( _gmo ) ){
      char buffer[GMS_SSSIZE];
      gmoNameOptFile( _gmo, buffer );
      //couenne_setup->BabSetupBase::readOptionsFile(buffer);

      //std::string useroptions;
      //couenne_setup->options()->PrintUserOptions(useroptions);
      //gevLogPChar(gev, "List of user-set options (ignore column 'used'):\n");
      //gevLogPChar(gev, useroptions.c_str());
    }
  }
  catch( ... ){
    gevLogStat( _gev, "ERROR: Option file could not be processes.\n");
    return false;
  }

  // process variables and expressions
  _nvar = gmoN( _gmo );
  _var.resize( _nvar );
  _varini.resize( _nvar );
  _vartyp.resize( _nvar );
  _varlb.resize( _nvar );
  _varub.resize( _nvar );

  gmoGetVarL( _gmo, _varini.data() );
  gmoGetVarLower( _gmo, _varlb.data() );
  for( auto&& lb : _varlb )
    if( lb < -BASE_OPT::INF ) lb = -BASE_OPT::INF;
  gmoGetVarUpper( _gmo, _varub.data() );
  for( auto&& ub : _varub )
    if( ub >  BASE_OPT::INF ) ub =  BASE_OPT::INF;

  // reset DAG environment
  if( _dag ) delete _dag;
  BASE_AE::_dag = _dag = new FFGraph;

  // set DAG variables
  for( int i=0; i<_nvar; ++i ){
    _var[i].set( _dag );
    switch( gmoGetVarTypeOne( _gmo, i ) ){
      case gmovar_SC:
        _varlb[i] = 0e0;
        /* no break */
      case gmovar_X:
      case gmovar_S1:
      case gmovar_S2:
        _vartyp[i] = 0; // continuous variable
        break;

      case gmovar_SI:
        _varub[i] = 0e0;
        /* no break */
      case gmovar_B:
      case gmovar_I:
        _vartyp[i] = 1; // discrete variable
        break;

      default:
        gevLogStat( _gev, "Unknown variable type." );
        return false;
    }
    if( disp ){
      std::cout << "variable " << _var[i]
                << ": [ " << _varlb[i] << " : " << _varub[i] << " ] "
                << (_vartyp[i]?"disc":"cont") << std::endl;
    }
  }

  // set DAG functions
  int nz;
  int nlnz;
  std::vector<double> lincoefs( _nvar );
  std::vector<int> lincolidx( _nvar );
  std::vector<int> nlflag( _nvar );

  int nquad = gmoMaxQNZ( _gmo );
  std::vector<double> quadcoefs( nquad );
  std::vector<int> qrow( nquad );
  std::vector<int> qcol( nquad );

  std::vector<int> opcodes( gmoNLCodeSizeMaxRow(_gmo)+1 );
  std::vector<int> fields( gmoNLCodeSizeMaxRow(_gmo)+1 );
  //int constantlen = gmoNLConst( _gmo );
  double const* constants = (double*)gmoPPool( _gmo );
  int codelen;

  // set objective function
  gmoGetObjSparse( _gmo, lincolidx.data(), lincoefs.data(), nlflag.data(), &nz, &nlnz );
  FFVar objvar( gmoObjConst(_gmo) ); // initialize with constant objective term

  // linear/quadratic objective
  if( gmoGetObjOrder( _gmo ) <= gmoorder_Q ){

    //linear terms
    for( int i=0; i<nz; ++i )
      objvar += _var[lincolidx[i]] * lincoefs[i];

    // quadratic terms
    if( gmoGetObjOrder( _gmo ) == gmoorder_Q ){
      int qnz = gmoObjQNZ( _gmo );
      gmoGetObjQ( _gmo, qcol.data(), qrow.data(), quadcoefs.data() );
      for( int j=0; j<qnz; ++j ){
        assert( qcol[j] >= 0 && qcol[j] < _nvar && qrow[j] >= 0 && qrow[j] < _nvar );
        if( qcol[j] == qrow[j] )
          objvar += ( quadcoefs[j] / 2.0 ) * sqr( _var[qcol[j]] );
        else
          objvar += quadcoefs[j] * ( _var[qcol[j]] * _var[qrow[j]] );
      }
    }
  }

  // general nonlinear objective
  else{
    for( int i=0; i<nz; ++i ){
      if( nlflag[i] ) continue;
      objvar += _var[lincolidx[i]] * lincoefs[i];
    }

    gmoDirtyGetObjFNLInstr( _gmo, &codelen, opcodes.data(), fields.data() );
    // Not sure what check this is making...
    if( (gevGetIntOpt( _gev, gevInteger1) & 0x4) && (2651979 != gevGetIntOpt( _gev, gevInteger1)) )
      std::clog << "parse instructions for objective" << std::endl;
    
    auto [nlpart,def] = _parse( codelen, opcodes, fields, constants );
    if( !def ){
      gevLogStatPChar( _gev, "Error processing nonlinear instructions of objective equation.\n" );
      return false;
    }
    // Not sure why division by ObjJacVal is needed...
    objvar -= nlpart / gmoObjJacVal( _gmo );
  }

  if( disp )
    _dag->output( _dag->subgraph( 1, &objvar ), " objective" );
  //_objscal = (gmoSense( _gmo ) == gmoObj_Min? 1e0: -1e0);
  set_obj( gmoSense( _gmo ) == gmoObj_Min? MIN: MAX, objvar );


  // add constraints
  _nctr = gmoM( _gmo );
  for( int j = 0; j < _nctr; ++j )
  {
    gmoGetRowSparse( _gmo, j, lincolidx.data(), lincoefs.data(), nlflag.data(), &nz, &nlnz );
    FFVar ctrvar( 0e0 ); // initialize to 0

    // linear/quadratic constraint
    if( gmoGetEquOrderOne( _gmo, j ) <= gmoorder_Q )
    {
      //linear terms
      for( int i=0; i<nz; ++i )
        ctrvar += _var[lincolidx[i]] * lincoefs[i];

      // quadratic terms
      if( gmoGetEquOrderOne( _gmo, j ) == gmoorder_Q ){
        int qnz = gmoGetRowQNZOne( _gmo, j );
        gmoGetRowQ( _gmo, j, qcol.data(), qrow.data(), quadcoefs.data() );
        for( int k=0; k<qnz; ++k ){
          assert( qcol[k] >= 0 && qcol[k] < _nvar && qrow[k] >= 0 && qrow[k] < _nvar );
          if( qcol[k] == qrow[k] )
            ctrvar += ( quadcoefs[k] / 2.0 ) * sqr( _var[qcol[k]] );
          else
            ctrvar += quadcoefs[k] * ( _var[qcol[k]] * _var[qrow[k]] );
        }
      }
    }

    // general nonlinear constraint
    else{
      for( int i=0; i<nz; ++i ){
        if( nlflag[i] ) continue;
        ctrvar += _var[lincolidx[i]] * lincoefs[i];
      }

      gmoDirtyGetRowFNLInstr( _gmo, j, &codelen, opcodes.data(), fields.data() );
      // Not sure what check this is making...
      if( (gevGetIntOpt( _gev, gevInteger1) & 0x4) && (2651979 != gevGetIntOpt( _gev, gevInteger1)) )
        std::clog << "parse instructions for constraint " << j << std::endl;

      auto [nlpart,def] = _parse( codelen, opcodes, fields, constants );
      if( !def ){
        char buffer[256];
        sprintf( buffer, "Error processing nonlinear instructions of constraint equation %d.\n", j );
        gevLogStatPChar( _gev, buffer );
        return false;
      }
      ctrvar += nlpart;
    }

    switch( gmoGetEquTypeOne( _gmo, j ) )
    {
      case gmoequ_E:
        ctrvar -= gmoGetRhsOne( _gmo, j );
        add_ctr( EQ, ctrvar );
        break;
      case gmoequ_L:
        ctrvar -= gmoGetRhsOne( _gmo, j );
        add_ctr( LE, ctrvar );
        break;
      case gmoequ_G:
        ctrvar -= gmoGetRhsOne( _gmo, j );
        add_ctr( GE, ctrvar );
        break;
      case gmoequ_N:
        // ignore free constraints, should have been permutated out anyway
        break;
      case gmoequ_X:
        gevLogStat( _gev, "GAMS external functions not supported.\n" );
        return false;
      case gmoequ_C:
        gevLogStat( _gev, "GAMS conic constraints not supported.\n" );
        return false;
      case gmoequ_B:
        gevLogStat( _gev, "GAMS logic constraints not supported.\n" );
        return false;
      default:
        gevLogStat( _gev, "Unexpected constraint type.\n" );
        return false;
    }

    if( disp )
      _dag->output( _dag->subgraph( 1, &ctrvar ), " constraint" );
  }

//   if( (gevGetIntOpt(gev, gevInteger1) & 0x2) && (2651979 != gevGetIntOpt(gev, gevInteger1)) )
//      prob->print();
//   prob->initOptions(couenne_setup->options());

//   // if we made it until here, then we are successful, so store prob in prob_
//   prob_ = prob;

  gmoUseQSet( _gmo, 0 );
  return true;
}

inline
std::pair<FFVar,bool>
GAMSIO::_parse
( int const codelen, std::vector<int>& opcodes, std::vector<int>& fields,
  double const* constants )
{
  //bool debugoutput = true;
  bool debugoutput = (gevGetIntOpt(_gev, gevInteger1) & 0x4) && (2651979 != gevGetIntOpt(_gev, gevInteger1));
#define debugout if( debugoutput ) std::clog

  std::list<FFVar> stack;

  int nargs = -1;
  for( int pos = 0; pos < codelen; ++pos ){

    GamsOpCode opcode = (GamsOpCode)opcodes[pos];
    int address = fields[pos]-1;
    debugout << '\t' << GamsOpCodeName[opcode] << ": ";

    FFVar res;
    bool def = false;

    switch( opcode )
    {
      case nlNoOp:   // no operation
      case nlStore:  // store row
      case nlHeader: // header
        debugout << "ignored" << std::endl;
        break;

      case nlPushV: // push variable
        address = gmoGetjSolver( _gmo, address );
        debugout << "push variable " << address << std::endl;
        res = _var[address];
        def = true;
        break;

      case nlPushI: // push constant
        debugout << "push constant " << constants[address] << std::endl;
        res = constants[address];
        def = true;
        break;

      case nlPushZero: // push zero
        debugout << "push constant zero" << std::endl;
        res = 0e0;
        def = true;
        break;

      case nlAdd: // add
        debugout << "add" << std::endl;
        res  = stack.back();  stack.pop_back();
        res += stack.back(); stack.pop_back();
        def = true;
        break;
      
      case nlAddV: // add variable
        address = gmoGetjSolver( _gmo, address );
        debugout << "add variable " << address << std::endl;
        res  = stack.back(); stack.pop_back();
        res += _var[address];
        def = true;
        break;

      case nlAddI: // add immediate
        debugout << "add constant " << constants[address] << std::endl;
        res = stack.back(); stack.pop_back();
        res += constants[address];
        def = true;
        break;
        
      case nlUMin: // unary minus
        debugout << "negate" << std::endl;
        res = -stack.back(); stack.pop_back();
        def = true;
        break;

      case nlUMinV: // unary minus variable
        address = gmoGetjSolver( _gmo, address );
        debugout << "push negated variable " << address << std::endl;
        res = -_var[address];
        def = true;
        break;

      case nlSub: // subtract
      {
        debugout << "subtract" << std::endl;
        FFVar term1 = stack.back(); stack.pop_back();
        res  = stack.back(); stack.pop_back();
        res -= term1;
        def = true;
        break;
      }
 
      case nlSubV: // subtract variable
        address = gmoGetjSolver( _gmo, address );
        debugout << "subtract variable " << address << std::endl;
        res  = stack.back(); stack.pop_back();
        res -= _var[address];
        def = true;
        break;

      case nlSubI: // subtract immediate
        debugout << "subtract constant " << constants[address] << std::endl;
        res  = stack.back(); stack.pop_back();
        res -= constants[address];
        def = true;
        break;

      case nlMul: // multiply
        debugout << "multiply" << std::endl;
        res  = stack.back(); stack.pop_back();
        res *= stack.back(); stack.pop_back();
        def = true;
        break;

      case nlMulV: // multiply variable
        address = gmoGetjSolver( _gmo, address );
        debugout << "multiply variable " << address << std::endl;
        res  = stack.back(); stack.pop_back();
        res *= _var[address];
        def = true;
        break;

      case nlMulI: // multiply immediate
        debugout << "multiply constant " << constants[address] << std::endl;
        res  = stack.back(); stack.pop_back();
        res *= constants[address];
        def = true;
        break;

      case nlMulIAdd: // multiply immediate add
        debugout << "multiply constant " << constants[address] << " and add " << std::endl;
        res  = stack.back(); stack.pop_back();
        res *= constants[address];
        res += stack.back(); stack.pop_back();
        def = true;
        break;

      case nlDiv: // divide
      {
        debugout << "divide" << std::endl;
        FFVar term1 = stack.back(); stack.pop_back();
        res  = stack.back(); stack.pop_back();
        res /= term1;
        def = true;
        break;
      }
 
      case nlDivV: // divide variable
        address = gmoGetjSolver( _gmo, address );
        debugout << "divide variable " << address << std::endl;
        res  = stack.back(); stack.pop_back();
        res /= _var[address];
        def = true;
        break;

      case nlDivI: // divide immediate
        debugout << "divide constant " << constants[address] << std::endl;
        res  = stack.back(); stack.pop_back();
        res /= constants[address];
        def = true;
        break;

      case nlFuncArgN: // number of function arguments
        nargs = address + 1;  // undo shift by 1
        debugout << nargs << " arguments" << std::endl;
        break;

      case nlCallArg1 :
        nargs = 1;
        /* no break */
      case nlCallArg2 :
        if( opcode == nlCallArg2 )
          nargs = 2;
          /* no break */
      case nlCallArgN :
      {
        debugout << "call function ";

        switch( GamsFuncCode(address+1) )  // undo shift by 1
        {
          case fnpi:
            debugout << "pi" << std::endl;
            res = PI;
            def = true;
            break;

          case fnmin:
          {
            debugout << "min" << std::endl;
            FFVar term1 = stack.back(); stack.pop_back();
            FFVar term2 = stack.back(); stack.pop_back();
            res = min( term1, term2 );
            def = true;
            break;
          }

          case fnmax:
          {
            debugout << "max" << std::endl;
            FFVar term1 = stack.back(); stack.pop_back();
            FFVar term2 = stack.back(); stack.pop_back();
            res = max( term1, term2 );
            def = true;
            break;
          }

          case fndiv:
          {
            debugout << "divide" << std::endl;
            FFVar term1 = stack.back(); stack.pop_back();
            res  = stack.back(); stack.pop_back();
            res /= term1;
            def = true;
            break;
          }

          case fnsqr:
            debugout << "sqr" << std::endl;
            res = sqr( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnexp:
            debugout << "exp" << std::endl;
            res = exp( stack.back() ); stack.pop_back();
            def = true;
            break;
            
          case fnlog:
            debugout << "log" << std::endl;
            res = log( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnlog10:
            debugout << "log10" << std::endl;
            res = log( stack.back() ) * ( 1e0 / std::log(1e1) ); stack.pop_back();
            def = true;
            break;

          case fnlog2:
            debugout << "log2" << std::endl;
            res = log( stack.back() ) * ( 1e0 / std::log(2e0) ); stack.pop_back();
            def = true;
            break;

          case fnsqrt:
            debugout << "sqrt" << std::endl;
            res = sqrt( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnabs:
            debugout << "abs" << std::endl;
            res = fabs( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnerrf: 
            debugout << "erf" << std::endl;
            res = erf( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fncos:
            debugout << "cos" << std::endl;
            res = cos( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnsin:
            debugout << "sin" << std::endl;
            res = sin( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fntan:
            debugout << "tan" << std::endl;
            res = tan( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fncosh:
            debugout << "cosh" << std::endl;
            res = cosh( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnsinh:
            debugout << "sinh" << std::endl;
            res = sinh( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fntanh:
            debugout << "tanh" << std::endl;
            res = tanh( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnarccos:
            debugout << "acos" << std::endl;
            res = acos( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnarcsin:
            debugout << "asin" << std::endl;
            res = asin( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnarctan:
            debugout << "atan" << std::endl;
            res = atan( stack.back() ); stack.pop_back();
            def = true;
            break;

          case fnpower:  // x ^ y
          case fnrpower: // x ^ y
          case fncvpower: // constant ^ x
          case fnvcpower: // x ^ constant
          {
            debugout << "power" << std::endl;
            FFVar term1 = stack.back(); stack.pop_back();
            FFVar term2 = stack.back(); stack.pop_back();
            res = pow( term2, term1 );
            def = true;
            break;
          }

          case fnsign:
            debugout << "sign" << std::endl;
            res = fstep( stack.back() ) - bstep( stack.back() ); stack.pop_back();
            def = true;
            break;
            
          case fnsignpower:
          {
            debugout << "signpower" << std::endl;
            FFVar term1 = stack.back(); stack.pop_back();
            res = stack.back() * pow( fabs( stack.back() ), term1-1 ) ; stack.pop_back();
            def = true;
            break;
          }

          case fnpoly: /* univariate polynomial */
          {
            debugout << "univariate polynomial of degree " << nargs-2 << std::endl;
            assert(nargs > 0);
            switch( nargs )
            {
              case 1:
                stack.pop_back(); // erase variable of polynomial
                res = 0e0;
                break;
 
              case 2: // "constant" polynomial
                res = stack.back(); stack.pop_back();
                stack.pop_back(); // erase variable of polynomial
                break;

              default: // polynomial is at least linear
              {
                std::vector<double> coef(nargs-1);
                while( nargs > 1 )
                {
                  assert( !stack.empty() && stack.back().cst() );
                  coef[nargs-2] = stack.back().num().val();
                  stack.pop_back();
                  --nargs;
                }
                assert( !stack.empty() );
                FFVar var = stack.back(); stack.pop_back();
                res = coef[0] + coef[1] * var;
                for( unsigned i=2; i<coef.size(); ++i )
                  res += coef[i] * pow( var, (int)i );
              }
            }
            nargs = -1;
            break;
          }

//               // TODO some more we could handle
//               case fnceil: case fnfloor: case fnround:
//               case fnmod: case fntrunc: case fnsign:
//               case fndunfm:
//               case fndnorm: case fnerror: case fnfrac: case fnerrorl:
//               case fnfact /* factorial */:
//               case fnunfmi /* uniform random number */:
//               case fnncpf /* fischer: sqrt(x1^2+x2^2+2*x3) */:
//               case fnncpcm /* chen-mangasarian: x1-x3*ln(1+exp((x1-x2)/x3))*/:
//               case fnentropy /* x*ln(x) */: case fnsigmoid /* 1/(1+exp(-x)) */:
//               case fnboolnot: case fnbooland:
//               case fnboolor: case fnboolxor: case fnboolimp:
//               case fnbooleqv: case fnrelopeq: case fnrelopgt:
//               case fnrelopge: case fnreloplt: case fnrelople:
//               case fnrelopne: case fnifthen:
//               case fnedist /* euclidian distance */:
//               case fncentropy /* x*ln((x+d)/(y+d))*/:
//               case fngamma: case fnloggamma: case fnbeta:
//               case fnlogbeta: case fngammareg: case fnbetareg:
//               case fnncpvusin /* veelken-ulbrich */:
//               case fnncpvupow /* veelken-ulbrich */:
//               case fnbinomial:
//               case fnarctan2 /* arctan(x2/x1) */:
          default:
          {
            char buffer[256];
            sprintf(buffer, "GAMS function %s not supported.", GamsFuncCodeName[address+1]);
            gevLogStat( _gev, buffer );
            return std::make_pair( res, def );
          }
        }
        break;
      }

      default:
      {
        char buffer[256];
        sprintf( buffer, "GAMS opcode %s not supported.", GamsOpCodeName[opcode]);
        gevLogStat( _gev, buffer );
        return std::make_pair( res, def );
      }
    }

    if( !def ) continue;
    stack.push_back( res );
  }

  assert( stack.size() == 1 );
  return std::make_pair( stack.back(), true );
#undef debugout
}

} // end: namespace mc
#endif // MC__GAMSIO_HPP
